将程序入口改为MainActivity重新打包



cmd5查出key为ExpectoPatronum

带入后输入ISCC{ABCDEFGHIJKLMNOPQRST}

hook

```js
Java.perform(function() {
    var Intent = Java.use('android.content.Intent');
    var Activity = Java.use('android.app.Activity');
    
    // 获取当前Activity上下文
    var currentActivity = Java.use('android.app.ActivityThread').currentActivity();
    
    // 创建Intent
    var intent = Intent.$new();
    intent.setClassName(currentActivity, "com.example.ggad.MainActivity");
    
    // 添加FLAG_ACTIVITY_NEW_TASK标志（如果需要）
    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK.value);
    
    // 启动Activity
    currentActivity.startActivity(intent);
});

//frida -U -f "com.example.ggad" -l hook.js
```



将PRESET_VALUE与上面得到的结果带入

```python
# 给定的二进制字符串
ci = '0100001000110100010001000011001100110111001100110100010000110000001101000011001101000110001101100100010000110000'
c2 = '65489E5B5D3BB0'

c1 = ''
for i in range(0, len(ci), 8):
    c1 += chr(int(ci[i:i + 8], 2))

c = ''

for i in range(14):
        c+=c1[i]
        c+=c2[i]

byte_array = [int(c[i:i+2], 16) for i in range(0, len(c), 2)]

c3 = ''
for i in byte_array:
    a = bin(i)[2:]
    c3 += ("{:0>8}".format(a))

str1 = ''
for i in c3:
    if(i == '1'):
        str1 += '0'
    if(i == '0'):
        str1 += '1'

c4 = []
for i in range(0, len(str1), 8):
    c4.append(int(str1[i:i + 8], 2))
final_cipher = bytes(c4)

def rc4_ksa(key):
    """密钥调度算法 (KSA)

    得到初始置换后的S表
    """
    # 种子密钥key若为字符串，则转成字节串
    if isinstance(key, str):  
        key = key.encode()
    S = list(range(256))  # 初始化S表
    # 利用K表，对S表进行置换
    j = 0
    for i in range(256):
        j = (j + S[i] + key[i % len(key)]) % 256
        S[i], S[j] = S[j], S[i]  # 置换
    return S  


def rc4_prga(S, text):
    """伪随机生成算法 (PRGA)

    利用S产生伪随机字节流,
    将伪随机字节流与明文或密文进行异或,完成加密或解密操作
    """
    # 待处理文本text若为字符串，则转成字节串
    if isinstance(text, str):  
        text = text.encode()
    i = j = 0 
    result = []  
    count=0
    for byte in text:
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        S[i], S[j] = S[j], S[i]  # 置换
        t = (S[i] + S[j]) % 256
        k = S[t]  # 得到密钥字k
        # 将明文或密文与k进行异或,得到处理结果
        result.append(byte ^ k)  
    return bytes(result)

S = rc4_ksa('ExpectoPatronum')
res = rc4_prga(S, final_cipher)
flag = "ISCC{" + res.decode() +"}"
print(flag)


```

